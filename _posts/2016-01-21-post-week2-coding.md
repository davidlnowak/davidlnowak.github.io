---
layout: post
title: 'Going back to the future:'
description: 'Initial musings on coding'
categories: coding weekly
---

---


I have been programming for more years than I am going to admit in this post.  My career as a professional developer started with COBOL running on Digital Equipment Corporation (DEC) computers including the PDP-11 series and VAX—equipment that exists only in museums today.

My coding work throughout my career has been in the service of business—manufacturing and finance.  As such, the product of my coding is by necessity all business oriented—a space where there exists no bouncing balls or crudely drawn cars and houses.  A world only of facts, statistics, lookups, and reports.  The coding of this world is by no means experimental—there is little time for such.  To the degree that there is any experimentation it is always with a focus of how existing coding paradigms can be extended into new or evolving technologies.  

Professional software development is a world of patterns and time tested principles.  SOLID is an example of such principles where each letter of the mnemonic represents a particular aspect of object-oriented practices: S-Single responsibility; O-Open/closed; L-Liskov substitution; I-Interface segregation; and D-Dependency inversion.  A good description of these can be found [here.](https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)

> **So, what have I learned in the first two weeks of this class?**

I have learned that programming can be actually be fun—again.  At the moment I’m not worrying about aesthetics or how the user will interact with my software or how to dummy-proof my application.  I’m experimenting; I’m playing.  I’m treating each line of code with a renewed sense of discovery.  I read [Diana's coding blog](http://dianarosenberger.github.io/blog/2016-01-27/week2-2ndpost.html), and her note that she needs to "understand in order to move on" resonates with me.  Software can be developed in varying ways.  Programmers who don't understand certain concepts can generally achieve similar, if not the same, end results by resorting to different code constructs.  Eventually, however, the failure to understand certain principles will eventually impair one's ability to produce elegant code and/or to move on to advanced topics.

The most difficult aspect of this for me is, for the moment, in forgetting what I know and what I think I know.  I want this truly be an act of discovery and uncovering—not an automatic process of simply discerning the appropriate methodology to use and pattern to apply to the problem at hand.  Anything short of this will only serve to limit the possibilities of what I can possibly achieve.  I want through this process to be able to ask questions that I haven’t yet thought of, and to find solutions to those questions without resorting back to previous practices.  


